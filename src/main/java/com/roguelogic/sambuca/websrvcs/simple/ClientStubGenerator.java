/*
 * Created on Apr 6, 2008
 */

/*
 Copyright 2008 Robert C. Ilardi

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

package com.roguelogic.sambuca.websrvcs.simple;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringReader;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import com.roguelogic.sambuca.websrvcs.SambucaWebServiceException;
import com.roguelogic.util.HttpServletCallData;
import com.roguelogic.util.HttpServletCaller;
import com.roguelogic.util.StringUtils;

/**
 * @author rilardi
 */

public class ClientStubGenerator {

  public static final String GENERATOR_NAME = "Sambuca Simple Web Service Client Stub Generator";
  public static final String GENERATOR_VERSION = "1.0";

  public static final String CODE_GENERATION_NOTICE = "The Class(es) generated by the Code Generator should NOT be changed manually!";

  public static final String LICENSE = " * Copyright 2008 Robert C. Ilardi\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.";

  private String inventoryUrl;
  private String outputPackageName;
  private String outputDir;

  public ClientStubGenerator() {
  }

  public String getInventoryUrl() {
    return inventoryUrl;
  }

  public void setInventoryUrl(String inventoryUrl) {
    this.inventoryUrl = inventoryUrl;
  }

  public String getOutputDir() {
    return outputDir;
  }

  public void setOutputDir(String outputDir) {
    this.outputDir = outputDir;
  }

  public String getOutputPackageName() {
    return outputPackageName;
  }

  public void setOutputPackageName(String outputPackageName) {
    this.outputPackageName = outputPackageName;
  }

  public void generateStubs() throws IOException, SAXException, SambucaWebServiceException {
    String inventoryXml, packageDir;
    ClientInventory inventory;

    inventoryXml = getInventoryXml();

    inventory = parseInventoryXML(inventoryXml);

    packageDir = createPackageDir();

    generateClientCode(packageDir, inventory);
  }

  private String getInventoryXml() throws IOException {
    HttpServletCaller caller;
    HttpServletCallData data;
    String inventoryXml;

    caller = new HttpServletCaller(inventoryUrl); //http://localhost:8181/?action=GET-WS-INVENTORY

    data = caller.sendParameters(null);

    inventoryXml = data.getPayloadData();

    return inventoryXml;
  }

  private String createPackageDir() {
    File dir;
    String packageDir;

    packageDir = outputPackageName.replaceAll("\\.", "/");
    packageDir = (new StringBuffer()).append(outputDir).append("/").append(packageDir).toString();

    dir = new File(packageDir);
    dir.mkdirs();

    return packageDir;
  }

  private ClientInventory parseInventoryXML(String xml) throws SAXException, IOException {
    XMLReader xReader = null;
    InventoryXMLParser parser;
    StringReader sReader = null;
    InputSource ins;
    ClientInventory inventory = null;

    try {
      sReader = new StringReader(xml);
      xReader = XMLReaderFactory.createXMLReader();
      parser = new InventoryXMLParser();
      ins = new InputSource(sReader);

      xReader.setContentHandler(parser);
      xReader.setErrorHandler(parser);

      xReader.parse(ins);

      inventory = parser.getInventory();
    } //End try block
    finally {
      if (sReader != null) {
        sReader.close();
      }
    }

    return inventory;
  }

  private void generateClientCode(String packageDir, ClientInventory inventory) throws IOException, SambucaWebServiceException {
    //Generator Client Facade Class
    generateClientFacade(packageDir, inventory);
  }

  private void generateClientFacade(String packageDir, ClientInventory inventory) throws IOException, SambucaWebServiceException {
    FileOutputStream fos = null;
    String clientStubClassName, clientStubFilename, clientStubFilePath;
    StringBuffer buf;

    try {
      //Prepare Class and File Names and Paths...
      clientStubClassName = inventory.getFacadeName();

      //Take the class name of the Facade only (remove package)
      if (clientStubClassName.indexOf(".") >= 0) {
        clientStubClassName = clientStubClassName.substring(clientStubClassName.lastIndexOf(".") + 1, clientStubClassName.length());
      }

      clientStubClassName = (new StringBuffer()).append(clientStubClassName).append("WSClient").toString();

      clientStubFilename = (new StringBuffer()).append(clientStubClassName).append(".java").toString();

      clientStubFilePath = (new StringBuffer()).append(packageDir).append("/").append(clientStubFilename).toString();
      fos = new FileOutputStream(clientStubFilePath);

      //Write File Header Comments
      writeGeneratorComments(fos, clientStubFilename);

      //Start Generating Client ------------------->
      buf = new StringBuffer();

      //Package
      buf.append("\npackage ");
      buf.append(outputPackageName);
      buf.append(";\n\n");

      //Imports
      buf.append("import java.io.IOException;\n");
      buf.append("import java.util.Properties;\n\n");

      buf.append("import com.roguelogic.util.HttpServletCaller;\n");
      buf.append("import com.roguelogic.util.HttpServletCallData;\n");
      buf.append("import com.roguelogic.sambuca.websrvcs.simple.WSDataCodec;\n\n");

      //Class Declaration
      buf.append("public final class ");
      buf.append(clientStubClassName);
      buf.append(" {\n\n");

      //Constants
      buf.append("  public static final String _SAMBUCA_WS_CLIENT_GENERATOR = \"");
      buf.append(GENERATOR_NAME);
      buf.append("\";\n");

      buf.append("  public static final String _SAMBUCA_WS_CLIENT_GENERATOR_VERSION = \"");
      buf.append(GENERATOR_VERSION);
      buf.append("\";\n");

      buf.append("  public static final String _SAMBUCA_WS_FACADE = \"");
      buf.append(inventory.getFacadeName());
      buf.append("\";\n\n");

      //Data Member / Field for web service url
      buf.append("  private String _sambucaWsUrl;\n\n");

      //Default Constructor
      buf.append("  public ");
      buf.append(clientStubClassName);
      buf.append("(String url) {\n    _sambucaWsUrl = url;\n  }\n\n");

      //Web Service API methods
      for (WSMethod method : inventory.getMethods()) {
        buf.append(generateMethodCode(method)); //Create Method
      } //End for each method loop

      buf.append("}\n");

      fos.write(buf.toString().getBytes());

      //End Generating Client ------------------->
    } //End try block
    finally {
      if (fos != null) {
        try {
          fos.close();
        }
        catch (Exception e) {
        }
      }
    }
  }

  private void writeGeneratorComments(OutputStream outs, String clientStubFilename) throws IOException {
    StringBuffer comments = new StringBuffer();

    comments.append("/*\n");

    comments.append(" * ");
    comments.append(clientStubFilename);
    comments.append("\n *\n");

    comments.append(" * Generated on ");
    comments.append(StringUtils.GetTimeStamp());
    comments.append("\n *\n");

    comments.append(" * Generator: ");
    comments.append(GENERATOR_NAME);
    comments.append("\n *\n");

    comments.append(" * Generator Version: ");
    comments.append(GENERATOR_VERSION);
    comments.append("\n *\n");

    comments.append(" * Facade Inventory URL: ");
    comments.append(inventoryUrl);
    comments.append("\n *\n");

    comments.append(" * Code Generation Notice: ");
    comments.append(CODE_GENERATION_NOTICE);
    comments.append("\n *\n");

    comments.append(" * License: Apache License V2.0\n *\n");
    comments.append(LICENSE);
    comments.append("\n *\n");

    comments.append(" */\n");

    outs.write(comments.toString().getBytes());
  }

  private String generateMethodCode(WSMethod method) throws SambucaWebServiceException {
    StringBuffer buf = new StringBuffer();

    buf.append(generateMethodDeclaration(method)); //Start Method /Method Declaration
    buf.append(" {\n");
    buf.append(generateMethodImpl(method)); //Method Body / Method Definition / Implementation
    buf.append("  }\n\n"); //End Method.............

    return buf.toString();
  }

  private String generateMethodDeclaration(WSMethod method) {
    StringBuffer buf = new StringBuffer();
    WSParameter param;
    int argCnt = 1;

    //Generate Method Declaration ---------------------->

    buf.append("  public ");

    param = method.getReturnType();
    buf.append(param.getTypeName());

    if (param.isArray()) {
      buf.append("[] ");
    }
    else {
      buf.append(" ");
    }

    buf.append(method.getName());
    buf.append("(");

    for (int i = 0; i < method.getParameters().size(); i++) {
      if (i > 0) {
        buf.append(", ");
      }

      param = method.getParameters().get(i);

      buf.append(param.getTypeName());

      if (param.isArray()) {
        buf.append("[]");
      }

      buf.append(" arg");
      buf.append(argCnt);

      argCnt++;
    } //End for i loop through method parameters

    buf.append(") throws IOException");

    return buf.toString();
  }

  private String generateMethodImpl(WSMethod method) throws SambucaWebServiceException {
    StringBuffer buf = new StringBuffer();
    WSParameter param;

    //Generate Method Implementation ----------------->

    buf.append("    HttpServletCaller caller = new HttpServletCaller(_sambucaWsUrl);\n\n");

    buf.append("    Properties request = new Properties();\n");

    buf.append(getRequestBaseParamsCode(method));

    buf.append("\n");

    buf.append(getRequestWsParamsCode(method));

    buf.append("\n    HttpServletCallData response = caller.sendParameters(request);\n\n");

    buf.append("    ");

    param = method.getReturnType();
    buf.append(param.getTypeName());

    if (param.isArray()) {
      buf.append("[] ");
    }
    else {
      buf.append(" ");
    }

    buf.append("retVal = ");
    buf.append(determineDecodeMethodName(method.getReturnType()));
    buf.append("(response);\n\n");

    buf.append("    return retVal;\n");

    return buf.toString();
  }

  private String getRequestWsParamsCode(WSMethod method) throws SambucaWebServiceException {
    StringBuffer buf = new StringBuffer();
    WSParameter param;

    for (int i = 0; i < method.getParameters().size(); i++) {
      param = method.getParameters().get(i);

      buf.append("    request.setProperty(\"WSPARAM");
      buf.append(i + 1);
      buf.append("\", ");

      buf.append(determineEncodeMethodName(param));

      buf.append("(arg");
      buf.append(i + 1);
      buf.append("));\n");
    }

    return buf.toString();
  }

  private String determineDecodeMethodName(WSParameter returnType) throws SambucaWebServiceException {
    StringBuffer buf = new StringBuffer();

    buf.append("WSDataCodec.");

    if (returnType.isArray()) {
      if ("java.lang.String".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeStringArr");
      }
      else if ("int".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeIntegerArr");
      }
      else if ("float".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeFloatArr");
      }
      else if ("double".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeDoubleArr");
      }
      else if ("char".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeCharArr");
      }
      else if ("byte".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeByteArr");
      }
      else if ("short".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeShortArr");
      }
      else if ("long".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeLongArr");
      }
      else if ("boolean".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeBooleanArr");
      }
      else {
        throw new SambucaWebServiceException("Unsupported Data Type for Decode Method Selection! Array Data Type Name = " + returnType.getTypeName());
      }
    } //End if returnType.isArray() block
    else {
      if ("java.lang.String".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeString");
      }
      else if ("int".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeInteger");
      }
      else if ("float".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeFloat");
      }
      else if ("double".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeDouble");
      }
      else if ("char".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeChar");
      }
      else if ("byte".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeByte");
      }
      else if ("short".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeShort");
      }
      else if ("long".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeLong");
      }
      else if ("boolean".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("DecodeBoolean");
      }
      else {
        throw new SambucaWebServiceException("Unsupported Data Type for Decode Method Selection! Scalar Data Type Name = " + returnType.getTypeName());
      }
    } //End else block

    return buf.toString();
  }

  private String determineEncodeMethodName(WSParameter returnType) throws SambucaWebServiceException {
    StringBuffer buf = new StringBuffer();

    buf.append("WSDataCodec.");

    if (returnType.isArray()) {
      if ("java.lang.String".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeStringArr");
      }
      else if ("int".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeIntegerArr");
      }
      else if ("float".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeFloatArr");
      }
      else if ("double".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeDoubleArr");
      }
      else if ("char".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeCharArr");
      }
      else if ("byte".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeByteArr");
      }
      else if ("short".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeShortArr");
      }
      else if ("long".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeLongArr");
      }
      else if ("boolean".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeBooleanArr");
      }
      else {
        throw new SambucaWebServiceException("Unsupported Data Type for Encode Method Selection! Array Data Type Name = " + returnType.getTypeName());
      }
    } //End if returnType.isArray() block
    else {
      if ("java.lang.String".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeString");
      }
      else if ("int".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeInteger");
      }
      else if ("float".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeFloat");
      }
      else if ("double".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeDouble");
      }
      else if ("char".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeChar");
      }
      else if ("byte".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeByte");
      }
      else if ("short".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeShort");
      }
      else if ("long".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeLong");
      }
      else if ("boolean".equalsIgnoreCase(returnType.getTypeName())) {
        buf.append("EncodeBoolean");
      }
      else {
        throw new SambucaWebServiceException("Unsupported Data Type for Encode Method Selection! Scalar Data Type Name = " + returnType.getTypeName());
      }
    } //End else block

    return buf.toString();
  }

  private String getRequestBaseParamsCode(WSMethod method) {
    StringBuffer buf = new StringBuffer();

    buf.append("    request.setProperty(\"");
    buf.append(WSAutoMounterServiceHandler.PARAM_ACTION);
    buf.append("\", \"");
    buf.append(WSAutoMounterServiceHandler.ACTION_EXECUTE_WS_METHOD);
    buf.append("\");\n");

    buf.append("    request.setProperty(\"");
    buf.append(WSAutoMounterServiceHandler.PARAM_FACADE_NAME);
    buf.append("\", _SAMBUCA_WS_FACADE);\n");

    buf.append("    request.setProperty(\"");
    buf.append(WSAutoMounterServiceHandler.PARAM_SIGNATURE_KEY);
    buf.append("\", \"");
    buf.append(method.getSignatureKey());
    buf.append("\");\n");

    return buf.toString();
  }

  public static void main(String[] args) {
    ClientStubGenerator generator;
    int exitCd;

    if (args.length != 3) {
      System.err.println("java " + ClientStubGenerator.class.getName() + " [INVENTORY_URL] [OUTPUT_PACKAGE_NAME] [OUTPUT_DIR]");
      exitCd = 1;
    }
    else {
      try {
        generator = new ClientStubGenerator();

        generator.setInventoryUrl(args[0]);
        generator.setOutputPackageName(args[1]);
        generator.setOutputDir(args[2]);

        generator.generateStubs();

        exitCd = 0;
      } //End try block
      catch (Exception e) {
        e.printStackTrace();
        exitCd = 1;
      }
    }

    System.exit(exitCd);
  }

}
